# -*- coding: utf-8 -*-
# ***************************************************************************
# *   Copyright (c) 2021 Russell Johnson (russ4262) <russ4262@gmail.com>    *
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU Lesser General Public License (LGPL)    *
# *   as published by the Free Software Foundation; either version 2 of     *
# *   the License, or (at your option) any later version.                   *
# *   for detail see the LICENCE text file.                                 *
# *                                                                         *
# *   This program is distributed in the hope that it will be useful,       *
# *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
# *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
# *   GNU Library General Public License for more details.                  *
# *                                                                         *
# *   You should have received a copy of the GNU Library General Public     *
# *   License along with this program; if not, write to the Free Software   *
# *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  *
# *   USA                                                                   *
# *                                                                         *
# ***************************************************************************

import FreeCAD

# import Part
import Path.Geom as PathGeom
import Path.Log as PathLog
import time
import Macro_CombineRegions
import Gui_Input
import Tool_Controller
import generators.Utilities as GenUtils
import PathScripts.PathUtils as PathUtils
import generators.DropCut as DropCut

__title__ = "Path Clearing Generator Utilities"
__author__ = "russ4262 (Russell Johnson)"
__url__ = ""
__doc__ = "Macro to test multiple pattern generators using 2D and 3D."

if False:
    PathLog.setLevel(PathLog.Level.DEBUG, PathLog.thisModule())
    PathLog.trackModule(PathLog.thisModule())
else:
    PathLog.setLevel(PathLog.Level.INFO, PathLog.thisModule())

isDebug = True  # True if PathLog.getLevel(PathLog.thisModule()) == 4 else False
showDebugShapes = False


MODULE_NAME = "Macro_DropCut_3D"
OPTIMIZE = False
moveCnt = 0

# Project 2D wires onto 3D face(s)
def _getGeneratorModule(cutPattern):
    module = None
    if cutPattern == "Adaptive":
        import generators.Adaptive as module
    elif cutPattern == "Line":
        import generators.Line as module
    elif cutPattern == "Circle":
        import generators.Circle as module
    elif cutPattern == "CircleZigZag":
        import generators.CircleZigZag as module
    elif cutPattern == "ZigZag":
        import generators.ZigZag as module
    elif cutPattern == "Offset":
        import generators.Offset as module
    elif cutPattern == "Profile":
        import generators.Profile as module
    elif cutPattern == "Spiral":
        import generators.Spiral as module
    else:
        FreeCAD.Console.PrintError(
            f"Did not find selected cut pattern, {cutPattern}.\n"
        )

    module.isDebug = isDebug
    module.showDebugShapes = showDebugShapes

    return module


def _identifyRegion(faces, offsetValue, cutPattern):
    # combine faces into horizontal regions
    region = Macro_CombineRegions.combineRegions(
        faces, saveExistingHoles=True, saveMergedHoles=True
    )
    # Part.show(region, "Region")

    # fuse faces together for projection of path geometry
    faceShape = fuseShapes(faces)

    if cutPattern in ["Adaptive", "Offset", "Profile"]:
        return region, faceShape

    offsetWF = PathUtils.getOffsetArea(region, offsetValue)
    if not offsetWF:
        GenUtils._debugMsg(MODULE_NAME, "getOffsetArea() failed")
        return None, faceShape
    if len(offsetWF.Faces) == 0:
        GenUtils._debugMsg(MODULE_NAME, "No offset faces to process for path geometry.")
        return None, faceShape

    return offsetWF, faceShape


def fuseShapes(shapes):
    size = len(shapes)
    if size == 0:
        return None
    if size == 1:
        return shapes[0].copy()
    fusion = shapes[0]
    for s in shapes[1:]:
        f = fusion.fuse(s)
        fusion = f
    return fusion


def execute(
    faces,
    toolController,
    job,
    pathType,
    cutPattern,
    cutDirection,
    stepOver,
    patternAngle,
    cutPatternCenterAt,
    cutPatternCenterCustom,
    reverseCutPattern,
    sampleInterval,
    dropTolerance=0.1,
    finalDepth=None,
    depthOffset=0.0,
    optimizeLines=False,
):

    generatorModule = _getGeneratorModule(cutPattern)
    if generatorModule is None:
        return [], []

    if len(faces) == 0:
        GenUtils._debugMsg(MODULE_NAME, "No faces for target region(s).")
        return [], []

    toolDiameter = (
        toolController.Tool.Diameter.Value
        if hasattr(toolController.Tool.Diameter, "Value")
        else float(toolController.Tool.Diameter)
    )
    toolRadius = toolDiameter / 2.0

    jobTolerance = (
        job.GeometryTolerance.Value if job.GeometryTolerance.Value > 0.0 else 0.01
    )
    _offsetDirection = -1.0  # 1.0=outside;  -1.0=inside
    # offsetValue = _offsetDirection * (toolRadius - (jobTolerance / 10.0))
    offsetValue = _offsetDirection * toolRadius

    # Process faces for path geometry
    region, faceShape = _identifyRegion(faces, offsetValue, cutPattern)
    fBB = faceShape.BoundBox

    # print(f"Tool radius: {toolRadius},  Step-over: {stepOver}")

    # Set cut speeds from tool controller
    GenUtils._setCutSpeeds(generatorModule, toolController)

    if cutPattern == "Adaptive":
        generatorModule.setAdaptiveAttributes(
            useHelixEntry=False,
            materialAllowance=0.0,
            operationType="Clearing",
            cutSide="Inside",
            forceInsideOut=True,
            liftDistance=5.0,
            finishingProfile=False,
            helixAngle=5.0,
            helixConeAngle=0.0,
            useHelixArcs=False,
            helixDiameterLimit=toolRadius * 1.9,
            keepToolDownRatio=2.0,
            adaptiveTolerance=0.1,
            clearanceHeight=fBB.ZMax + 10.0,
            safeHeight=fBB.ZMax + 5.0,
            startDepth=fBB.ZMax + 1.0,
            stockObj=job.Stock,
        )

    keepToolDown = False
    retractHeight = fBB.ZMax + 5.0
    keepToolDownThreshold = 5.0
    startPoint = None

    pathGeomList = generatorModule.generatePathGeometry(
        region,
        toolRadius,
        stepOver,
        cutDirection,
        patternCenterAt=cutPatternCenterAt,
        patternCenterCustom=cutPatternCenterCustom,
        cutPatternAngle=patternAngle,
        cutPatternReversed=reverseCutPattern,
        minTravel=False,
        keepToolDown=False,
        jobTolerance=0.01,
    )

    # Debugging - show 2D path wires
    # Part.show(Part.makeCompound(pathGeomList), "rawPathGeomList")

    if pathType == "3D":
        GenUtils._debugMsg(MODULE_NAME, "building 3D path")
        # Apply drop cut to 3D projected wires to get point set
        pointsLists = DropCut.dropCutWires(
            pathGeomList,
            faceShape,
            DropCut.getToolShape(toolController),
            sampleInterval,
            dropTolerance,
            optimizeLines,
        )

        lines = DropCut.pointsToLines(pointsLists, depthOffset)
        if cutPattern == "Adaptive":
            paths = generatorModule.geometryToGcode3D(lines, retractHeight, finalDepth)
        else:
            paths = generatorModule.geometryToGcode(
                lines,
                retractHeight,
                finalDepth,
                keepToolDown,
                keepToolDownThreshold,
                startPoint,
                toolRadius,
            )
    else:
        GenUtils._debugMsg(MODULE_NAME, "making 2D path")
        if finalDepth is None:
            finalDepth = fBB.ZMax

        lines = pathGeomList
        # paths = generatorModule.geometryToGcode(lines, toolController, retractHeight, finalDepth)
        paths = generatorModule.geometryToGcode(
            lines,
            retractHeight,
            finalDepth,
            keepToolDown,
            keepToolDownThreshold,
            startPoint,
            toolRadius,
        )

    return paths, lines


# Auxillary functions
def getFacesFromSelection():
    if not FreeCAD.GuiUp:
        return []

    import FreeCADGui

    faces = []
    selection = FreeCADGui.Selection.getSelectionEx()
    # process user selection
    for sel in selection:
        # print(f"Object.Name: {sel.Object.Name}")
        if len(sel.SubElementNames) > 0:
            for feat in sel.SubElementNames:
                # print(f"Processing: {sel.Object.Name}::{feat}")
                if feat.startswith("Face"):
                    # face = sel.Object.Shape.getElement(feat)
                    faces.append(sel.Object.Shape.getElement(feat))
        else:
            obj = sel.Object
            # fcs = [f.copy() for f in obj.Shape.Faces[1:]]
            # faces.append(fuseShapes(fcs))
            for f in obj.Shape.Faces[1:]:
                faces.append(f)

    return faces


def getUserInput():

    # Get path type from user
    guiInput = Gui_Input.GuiInput()
    guiInput.setWindowTitle("Path Details")
    guiInput.addComboBox("Cut Pattern", GenUtils.PATTERNS)
    guiInput.addComboBox("Path Type", GenUtils.PATHTYPES)
    guiInput.addDoubleSpinBox("Step over %", 100.0)
    guiInput.getInputByIndex(2).setMaximum(100.0)
    guiInput.getInputByIndex(2).setMinimum(0.0)
    guiInput.getInputByIndex(2).setValue(75.0)
    guiInput.addComboBox("Cut Direction", GenUtils.CUTDIRECTIONS)
    guiInput.addDoubleSpinBox("Cut Pattern Angle", 0.0)
    guiInput.getInputByIndex(4).setMaximum(360.0)
    guiInput.getInputByIndex(4).setMinimum(0.0)
    guiInput.addComboBox("Cut Pattern Center At", GenUtils.PATTERNCENTERS)
    x, y, z = guiInput.addDoubleVector(
        "Pattern Center Custom", FreeCAD.Vector(0.0, 0.0, 0.0)
    )
    x.setMaximum(999999999.9)
    x.setMinimum(-999999999.9)
    y.setMaximum(999999999.9)
    y.setMinimum(-999999999.9)
    z.setMaximum(999999999.9)
    z.setMinimum(-999999999.9)
    guiInput.addDoubleSpinBox("Sample interval", 1.0)
    guiInput.addCheckBox("Reverse Cut Pattern")
    guiInput.addCheckBox("Optimize paths")
    guiInput.addCheckBox("Test All Patterns")
    guiInput.getInputByIndex(9).setValue(True)
    return guiInput.execute()


def runMacro():
    global OPTIMIZE

    GenUtils.isDebug = isDebug
    GenUtils.showDebugShapes = showDebugShapes
    DropCut.MAX_DROPS = 75

    targetFaces = getFacesFromSelection()
    if len(targetFaces) == 0:
        return

    # Part.show(Part.makeCompound(targetFaces), "TargetFaces")
    values = getUserInput()
    if not values:
        return
    (
        cutPattern,
        pathType,
        stepOver,
        cutDirection,
        patternAngle,
        patternCenterAt,
        patternCenterCustom,
        sampleInterval,
        reverseCutPattern,
        optimize,
        testAll,
    ) = values
    OPTIMIZE = optimize

    if testAll:
        testAllCutPatterns(
            pathType,
            stepOver,
            cutDirection,
            patternAngle,
            patternCenterAt,
            patternCenterCustom,
            sampleInterval,
            reverseCutPattern,
        )
        return

    timeStart = time.time()
    GenUtils._debugMsg(MODULE_NAME, f"Pattern: {cutPattern}")

    # Set tool controller from Job object
    tc, jb = Tool_Controller.getToolController()
    job = None
    op = None
    for obj in FreeCAD.ActiveDocument.Objects:
        if obj.Name == "Job":
            job = obj
            break
    if job:
        import Path.Op.Gui.Custom as PathCustomGui

        op = PathCustomGui.PathCustom.Create("Custom")
        op.ToolController = tc
        op.ViewObject.Proxy = PathCustomGui.PathOpGui.ViewProvider(
            op.ViewObject, PathCustomGui.Command.res
        )
        op.ViewObject.Proxy.deleteOnReject = False
        # op.recompute()
        op.Label = cutPattern + "_" + pathType
        FreeCAD.ActiveDocument.recompute()
    else:
        FreeCAD.Console.PrintError("No Job object to receive paths.\n")
        return

    tolerance = 0.1
    paths, pathGeom = execute(
        targetFaces,
        tc,
        job,
        pathType,
        cutPattern,
        cutDirection,
        stepOver,
        patternAngle,
        patternCenterAt,
        patternCenterCustom,
        reverseCutPattern,
        sampleInterval,
        dropTolerance=tolerance,
        optimizeLines=optimize,
    )

    if len(paths) == 0:
        GenUtils._debugMsg(MODULE_NAME, "No path data recieved for Custom object.")
        workTime = time.time() - timeStart
        GenUtils._debugMsg(MODULE_NAME, f"Processing time: {workTime}")
        return

    if job:
        if isinstance(paths, list):
            op.Gcode = ["G90"] + [c.toGCode() for c in paths]
        else:
            op.Gcode = ["G90"] + [c.toGCode() for c in paths.Commands]
        FreeCAD.ActiveDocument.recompute()

    workTime = time.time() - timeStart
    GenUtils._debugMsg(MODULE_NAME, f"Processing time: {workTime}")


def testAllCutPatterns(
    pathType,
    stepOver,
    cutDirection,
    patternAngle,
    patternCenterAt,
    patternCenterCustom,
    sampleInterval,
    reverseCutPattern,
):
    vertOffset = 0.0

    """# Get path type from user
    guiInput = Gui_Input.GuiInput()
    guiInput.setWindowTitle("Select Path Type")
    guiInput.addComboBox("Path Type", GenUtils.PATHTYPES)
    values = guiInput.execute()
    if not values:
        FreeCAD.Console.PrintError("No user values returned.\n")
        return

    pathType = values[0]"""

    timeStart = time.time()
    targetFaces = getFacesFromSelection()
    # Set tool controller from Job object
    tc, jb = Tool_Controller.getToolController()
    if jb:
        job = jb
    else:
        job = None
        for obj in FreeCAD.ActiveDocument.Objects:
            if obj.Name == "Job":
                job = obj
                break

    if job:
        import Path.Op.Gui.Custom as PathCustomGui

    # for pat in ["Circle", "CircleZigZag"]:
    for trans, pat in GenUtils.PATTERNS:
        GenUtils._debugMsg(MODULE_NAME, f"Pattern and Path Type: {pat}, {pathType}")
        op = None
        if job:
            op = PathCustomGui.PathCustom.Create("Custom")
            op.ViewObject.Proxy = PathCustomGui.PathOpGui.ViewProvider(
                op.ViewObject, PathCustomGui.Command.res
            )
            op.ViewObject.Proxy.deleteOnReject = False
            op.ToolController = tc
            op.Label = pat + "_" + pathType
            # FreeCAD.ActiveDocument.recompute()
            # time.sleep(1)
        # sampleInterval = 1.0
        tolerance = 0.5
        # stepOver = 100.0
        paths, pathGeom = execute(
            targetFaces,
            tc,
            job,
            pathType,
            pat,
            cutDirection,
            stepOver,
            patternAngle,
            patternCenterAt,
            patternCenterCustom,
            reverseCutPattern,
            sampleInterval,
            dropTolerance=tolerance,
            depthOffset=vertOffset,
            optimizeLines=OPTIMIZE,
        )
        if job and paths is not None and len(paths) > 0:
            if isinstance(paths, list):
                op.Gcode = ["G90"] + [c.toGCode() for c in paths]
            else:
                op.Gcode = ["G90"] + [c.toGCode() for c in paths.Commands]
            FreeCAD.ActiveDocument.recompute()
            # time.sleep(1)

    workTime = time.time() - timeStart
    GenUtils._debugMsg(MODULE_NAME, f"Processing time: {workTime}")


print("\n\n\n\n")
print("Macro_DropCut3D::  Begin tool-specific path generation development macro")

runMacro()
